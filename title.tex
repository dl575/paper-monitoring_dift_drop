\title{
%Dataflow-Guided Filtering for Efficient and Adjustable Run-Time Monitoring
%Efficient and Adjustable Run-Time Monitoring Using Dataflow-Guided Filtering
Run-Time Monitoring with Adjustable Overheads Using Dataflow-Guided Filtering
}

\ifanonymized{\author{Anonymized}}
{\author{Daniel Lo, Tao Chen, Mohamed Ismail, and G. Edward Suh}}

\date{}
\maketitle

\thispagestyle{empty}

\begin{abstract}

Recent studies have proposed various parallel run-time monitoring techniques to
improve the reliability, security, and debugging capabilities of computer
systems. However, these run-time monitors can introduce large performance and energy
overheads, especially when performed on programmable cores.
%Traditionally, these overheads have been an
%all-or-nothing cost; monitoring cannot be used if the overheads are considered
%too large.  
In this paper, we introduce a hardware dataflow tracking engine that enables
adjustable overheads through partial monitoring. This allows a trade-off to be
made between monitoring coverage and overhead. This dataflow engine
can also be extended to filter out monitoring operations associated with null
metadata in order to reduce overheads.
% In this paper, we introduce a hardware dataflow tracking engine that can be
% used to filter out unnecessary monitoring and enable adjustable partial monitoring.
% The dataflow engine can identify events with null metadata so that they can
% be filtered out. To further reduce the overhead of monitoring, we propose
% to enable a trade-off between monitoring coverage and overhead by dropping certain
% monitoring operations. For this partial monitoring, the dataflow engine is used
% to track dropped monitoring flows so that false positives can be avoided.
Given this architecture, we investigate how the dropping decisions should be
made for partial monitoring and show that there exists a trade-off between closely
matching an overhead target and the coverage that can be achieved.
Our experimental results show that overheads can be reduced significantly 
by trading off coverage. For example, the proposed architecture can still
achieve 43-82\% coverage when the slowdown is reduced from 1.1-4.3x to 1.5x.
\ED{It's a bit strange to say reduced from 1.1x to 1.5x. Revise?}

\end{abstract}
