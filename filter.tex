\section{Filtering Monitoring Events}
\label{sec:filter}

For the instruction-grained monitoring techniques we consider, instructions in
the main program's execution are forwarded to the monitoring core based on
their instruction type (e.g., load, store, ALU, etc.).
However, not all of these forwarded instructions have relevant monitoring to be
done. For example, for array bounds check, all load and store instructions are
forwarded. However, only loads and stores associated with array pointers have
relevant monitoring operations to be done. Thus, we can greatly reduce the amount of
monitoring done by only forwarding instructions to the monitoring core that 
correspond to array pointers. These accesses can be identified because their
corresponding metadata has been initialized with base and bound address information.
More generally, we can reduce monitoring overheads by filtering out 
events that correspond to clean or uninitialized metadata.

% Overview of inserting dataflow engine
\begin{figure}
  \begin{center}
    \includegraphics[width=\columnwidth]{figs/dataflow_overview.pdf}
    \vspace{-0.2in}
    \caption{The dataflow engine is inserted between the main core and the monitoring core.}
    \label{fig:filter.overview} 
    \vspace{-0.1in}
  \end{center}
\end{figure}

In this section, we describe how we can use a dataflow tracking engine to
efficiently track clean metadata. This engine sits between the main core and
the monitoring core (see Figure~\ref{fig:filter.overview}) in order to filter
out monitoring operations for clean metadata.

\subsection{Dataflow Engine for Clean Metadata}

% Detailed architecture of dataflow engine
\begin{figure*}
  \begin{center}
    \includegraphics[width=\linewidth]{figs/dataflow_architecture.pdf}
    \vspace{-0.3in}
    \caption{Hardware architecture for dataflow engine.}
    \label{fig:filter.architecture} 
    \vspace{-0.1in}
  \end{center}
\end{figure*}

Figure~\ref{fig:filter.architecture} shows a block diagram of the dataflow
tracking engine for
keeping track of clean metadata. The engine keeps a \emph{clean flag}
corresponding to each piece of register and memory metadata. Initially, all
metadata is marked as clean.
When the monitoring core writes a non-null metadata value, it also sends a
signal to the dataflow engine to mark the metadata as dirty (i.e., initialized). 

When a monitoring event arrives at the dataflow engine,
it reads in up to two clean flags. These typically correspond to the source
operands of the monitored instruction but can be configured to other targets. 
This is done by configuring the inputs and operation of a pair of address
generation depending on instruction type.
For example, this can be used to keep clean flags at the word-level rather than
the byte-level by shifting memory addresses.

Given this pair of clean flags, a filter decision table decides, based
on instruction type, whether an event can be filtered out. This table is
configured based on the specific semantics of a monitoring technique.
Typically, if all clean flags are marked as clean, then the
event can be filtered out. For example, for array bounds check, if the source
register's metadata is marked as clean, then this means that the
register does not correspond to an array pointer. Thus, we can filter out the
monitoring operation for this event. 

It is important that we also propagate the clean information to the destination
of the instruction in order to prevent the use of stale (possibly non-clean) metadata.
The filter decision table also indicates
whether the destination operand metadata should be marked as clean.
